#
#	Authored 2018, Rae Zhao.
#
#	All rights reserved.
#
#	Redistribution and use in source and binary forms, with or without
#	modification, are permitted provided that the following conditions
#	are met:
#
#	*	Redistributions of source code must retain the above
#		copyright notice, this list of conditions and the following
#		disclaimer.
#
#	*	Redistributions in binary form must reproduce the above
#		copyright notice, this list of conditions and the following
#		disclaimer in the documentation and/or other materials
#		provided with the distribution.
#
#	*	Neither the name of the author nor the names of its
#		contributors may be used to endorse or promote products
#		derived from this software without specific prior written
#		permission.
#
#	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
#	"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
#	LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
#	FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
#	COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
#	INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
#	BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
#	LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
#	CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
#	LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
#	ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
#	POSSIBILITY OF SUCH DAMAGE.
#
#
#	Description: Base signals used in most Newton descriptions.
#
include "NewtonBaseSignals.nt"

#
#	Description: Additional signals used in this particular newton description.
#
accelerationNoise : signal =
{
	name = "micro g per square root of Hertz" English;
	symbol = n;
	derivation = 1E-6 * acceleration / (frequency ** 0.5);
}

microMagneto : signal =
{
	name = "micro Tesla" English;
	symbol = uT;
	derivation = 1E-6 * magneticFluxDensity;
}

#
#	Newton Description for the sensor BMX055 starts here.
#
#	Figures quoted here are referenced from Bosch BMX055 Sensor Module data sheet revision 1.0.
#
#	The constant is a value which can never be generated by the sensor. We use that to denote “impossible” or “invalid” readings.
#
kBMX055xAccelerationErasureToken	: constant = 16rFEFE;
kBMX055yAccelerationErasureToken	: constant = 16rFEFE;
kBMX055zAccelerationErasureToken	: constant = 16rFEFE;
kBMX055TemperatureErasureToken		: constant = 16rFEFE;

kBMX055xMagnetoErasureToken	: constant = 16rFEFE;
kBMX055yMagnetoErasureToken	: constant = 16rFEFE;
kBMX055zMagnetoErasureToken	: constant = 16rFEFE;

kBMX055xAngularRateErasureToken		: constant = 16rFEFE;
kBMX055yAngularRateErasureToken		: constant = 16rFEFE;
kBMX055zAngularRateErasureToken		: constant = 16rFEFE;

#
#	Standard Deviation is not available in data sheet.
#
kBMX055xAccelerationStdev		: constant = -1;
kBMX055yAccelerationStdev		: constant = -1;
kBMX055zAccelerationStdev		: constant = -1;
kBMX055TemperatureStdev			: constant = -1;

kBMX055xMagnetoStdev	: constant = -1;
kBMX055yMagnetoStdev	: constant = -1;
kBMX055zMagnetoStdev	: constant = -1;

kBMX055xAngularRateStdev		: constant = -1;
kBMX055yAngularRateStdev		: constant = -1;
kBMX055zAngularRateStdev		: constant = -1;

bmx055: sensor (
			bmx055xAcceleration: acceleration[0],
			bmx055yAcceleration: acceleration[1],
			bmx055zAcceleration: acceleration[2],
			bmx055Temperature: temperature,

			bmx055xMagneto: magneticFluxDensity[0],
			bmx055yMagneto: magneticFluxDensity[1],
			bmx055zMagneto: magneticFluxDensity[2],

			bmx055xAngularRate: angularRate[0],
			bmx055yAngularRate: angularRate[1],
			bmx055zAngularRate: angularRate[2]
			) =
{
	# ####################################
	#	Modality syntax proposal
	# ####################################
	# modality bmx055xAcceleration = {
	# OR
	# bmx055xAcceleration : modality = {
	# 	signal		= acceleration[0];
	# 	range  		= [-16 mjf, 16 mjf];
	# 	uncertainty	= Gaussian(bmx055xAcceleration, kBMX055xAccelerationStdev)*g;
	# 	erasuretoken	= kBMX055xAccelerationErasureToken;
	# 	precision	= {
	# 				(12*bits, -1),
	# 			};
	# 	accuracy	= {
	# 				(150*n, 312),
	# 			};
	# 	interface	= i2c (address: 16r18)
	# 	{
	# 		#
	# 		#	Start up at normal mode, modify (write value register) if set to other modes ...
	# 		#
	# 		#	Get MSB and LSB of xAccel data...
	# 		#
	# 		xAccelHigh := read 16r03;
	# 		xAccelLow  := read 16r02;
	# 		bmx055xAcceleration = (xAccelHigh << 4) | (xAccelLow >> 4);
	# 		# bmx055xAcceleration = xAccelHigh[:] + xAccelLow[4:];
	# 	};
	# }

	#
	#	The full range of the sensor
	#
	#	Range of Acceleration can be found in Table 2 on page 11.
	#
	#range bmx055xAcceleration == [-16 mjf, 16 mjf],
	#range bmx055yAcceleration == [-16 mjf, 16 mjf],
	#range bmx055zAcceleration == [-16 mjf, 16 mjf],

	range bmx055xAcceleration == [-2 mjf, 2 mjf],
    range bmx055yAcceleration == [-2 mjf, 2 mjf],
    range bmx055zAcceleration == [-2 mjf, 2 mjf],

	#
	#	Range of Temperature can be found in Table 2 on page 11.
	#
	range bmx055Temperature == [233.15 K, 358.15 K],

	#
	#	Range of Magnetic Field Density can be found in Table 4 on page 17.
	#
	range bmx055xMagneto == [-1300 uT, 1300 uT],
	range bmx055yMagneto == [-1300 uT, 1300 uT],
	range bmx055zMagneto == [-2500 uT, 2500 uT],

	#
	#	Range of Angular Rate can be found in Table 3 on page 14.
	#
	range bmx055xAngularRate == [-2000 ajf, 2000 ajf],
	range bmx055yAngularRate == [-2000 ajf, 2000 ajf],
	range bmx055zAngularRate == [-2000 ajf, 2000 ajf],

	#
	#	The operation sequence needed to get a sample
	#
	#	i2c address of Accelerometer can be found in Table 64 on page 145.
	#
	#	Register address of Accelerometer can be found in Figure 12 of document 6.2 on page 49.
	#
	interface bmx055xAcceleration == i2c (address: 16r18)
	{
		#
		#	Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#	Get MSB and LSB of xAccel data...
		#
		xAccelHigh := read 16r03;
		xAccelLow := read 16r02;
		bmx055xAcceleration = (xAccelHigh << 4) | (xAccelLow >> 4);
		# bmx055xAcceleration = xAccelHigh[:] + xAccelLow[4:];
	},

	interface bmx055yAcceleration == i2c (address: 16r18)
	{
		#
		#	Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#	Get MSB and LSB of yAccel data...
		#
		yAccelHigh := read 16r05;
		yAccelLow := read 16r04;
		bmx055yAcceleration = (yAccelHigh << 4) | (yAccelLow >> 4);
		# bmx055yAcceleration = yAccelHigh[:4] + yAccelLow[4:];
	},

	interface bmx055zAcceleration == i2c (address: 16r18)
	{
		#
		#	Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#	Get MSB and LSB of zAccel data...
		#

		zAccelHigh := read 16r07;
		zAccelLow  := read 16r06;
		bmx055zAcceleration = (zAccelHigh << 4) | (zAccelLow >> 4);
	},

	#
	#	Temperature sensor is part of the accelerometer so i2c address of Temperature Sensor is also 16r18.
	#
	#	Register address of temperature sensor can be found in Figure 12 of document 6.2 on page 49.
	#
	interface bmx055Temperature == i2c (address: 16r18)
	{
		#
		#	Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#	Get Temp data...
		#
		bmx055Temperature = read 16r08;
	},

	#
	#	i2c address of Magnetometer can be found in Table 64 on page 145.
	#
	#	Register address of Magnetometer can be found in document 10.2 on page 130.
	#
	interface bmx055xMagneto == i2c (address: 16r10)
	{
		#
		#	Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#	Get MSB and LSB of xMagneto data...
		#
		xMagnetoHigh := read 16r43;
		xMagnetoLow := read 16r42;
		bmx055xMagneto = (xMagnetoHigh << 5) | (xMagnetoLow >> 3);
	},

	interface bmx055yMagneto == i2c (address: 16r10)
	{
		#
		#	Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#	Get MSB and LSB of yMagneto data...
		#
		yMagnetoHigh := read 16r45;
		yMagnetoLow := read 16r44;
		bmx055yMagneto = (yMagnetoHigh << 5) | (yMagnetoLow >> 3);
	},

	interface bmx055zMagneto == i2c (address: 16r10)
	{
		#
		#	Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#	Get MSB and LSB of zMagneto data...
		#
		zMagnetoHigh := read 16r47;
		zMagnetoLow := read 16r46;
		bmx055zMagneto = (zMagnetoHigh << 7) | (zMagnetoLow >> 1);
	},

	#
	#	i2c address of Gyroscope can be found in Table 64 on page 145.
	#
	#	Register address of Gyroscope can be found in Figure 19 of document 8.2 on page 92.
	#
	interface bmx055xAngularRate == i2c (address: 16r68)
	{
		#
		#	Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#	Get MSB and LSB of xAngularRate data...
		#
		xAngularRateHigh := read 16r03;
		xAngularRateLow := read 16r02;
		bmx055xAngularRate = (xAngularRateHigh << 8) | (xAngularRateLow);
	},

	interface bmx055yAngularRate == i2c (address: 16r68)
	{
		#
		#	Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#	Get MSB and LSB of yAngularRate data...
		#
		yAngularRateHigh := read 16r05;
		yAngularRateLow := read 16r04;
		bmx055yAngularRate = (yAngularRateHigh << 8) | (yAngularRateLow);
	},

	interface bmx055zAngularRate == i2c (address: 16r68)
	{
		#
		#	Start up at normal mode, modify (write value register) if set to other modes ...
		#
		#	Get MSB and LSB of zAngularRate data...
		#
		zAngularRateHigh := read 16r07;
		zAngularRateLow := read 16r06;
		bmx055zAngularRate = (zAngularRateHigh << 8) | (zAngularRateLow);
	},

	#
	#	Uncertainty/noise model of the sensor as a function of mean value
	#
	#	Unsure about the function that describes the relationship between the following variables, so leave them as they are.
	#
	uncertainty bmx055xAcceleration == GaussianDistribution(mean: bmx055xAcceleration, stdev: kBMX055xAccelerationStdev),
	uncertainty bmx055yAcceleration == GaussianDistribution(mean: bmx055yAcceleration, stdev: kBMX055yAccelerationStdev),
	uncertainty bmx055zAcceleration == GaussianDistribution(mean: bmx055zAcceleration, stdev: kBMX055zAccelerationStdev),
	uncertainty bmx055Temperature == GaussianDistribution(mean: bmx055Temperature, stdev: kBMX055TemperatureStdev),

	uncertainty bmx055xMagneto == GaussianDistribution(mean: bmx055xMagneto, stdev: kBMX055xMagnetoStdev),
	uncertainty bmx055yMagneto == GaussianDistribution(mean: bmx055yMagneto, stdev: kBMX055yMagnetoStdev),
	uncertainty bmx055zMagneto == GaussianDistribution(mean: bmx055zMagneto, stdev: kBMX055zMagnetoStdev),

	uncertainty bmx055xAngularRate == GaussianDistribution(mean: bmx055xAngularRate, stdev: kBMX055xAngularRateStdev),
	uncertainty bmx055yAngularRate == GaussianDistribution(mean: bmx055yAngularRate, stdev: kBMX055yAngularRateStdev),
	uncertainty bmx055zAngularRate == GaussianDistribution(mean: bmx055zAngularRate, stdev: kBMX055zAngularRateStdev),

	#
	#	When this token is returned by the sensor, it denotes invalid sensed value / erasure in communication with sensor.
	#
	erasureToken bmx055xAcceleration == 16rFEFE,
	erasureToken bmx055yAcceleration == 16rFEFE,
	erasureToken bmx055zAcceleration == 16rFEFE,
	erasureToken bmx055Temperature == 16rFEFE,

	erasureToken bmx055xMagneto == 16rFEFE,
	erasureToken bmx055yMagneto == 16rFEFE,
	erasureToken bmx055zMagneto == 16rFEFE,

	erasureToken bmx055xAngularRate == 16rFEFE,
	erasureToken bmx055yAngularRate == 16rFEFE,
	erasureToken bmx055zAngularRate == 16rFEFE,

	#
	#	Precision settings list for the sensor. This is a list of (precision, cost) pairs.
	#
	#	The cost is a power or latency (or energy=power*time) cost for accessing values.
	#
	#	Cost has a unit of microwatts.
	#
	#	Could not find the relevant information in data sheet so I left the cost as 0.
	#
	precision bmx055xAcceleration == {
					(12, -1)
				},

	precision bmx055yAcceleration == {
					(12, -1)
				},

	precision bmx055zAcceleration == {
					(12, -1)
				},

	precision bmx055Temperature == {
					(8, -1)
				},

	precision bmx055xMagneto == {
						(13, -1)
					},

	precision bmx055yMagneto == {
						(13, -1)
					},

	precision bmx055zMagneto == {
						(15, -1)
					},

	precision bmx055xAngularRate == {
					(16, -1)
				},

	precision bmx055yAngularRate == {
					(16, -1)
				},

	precision bmx055zAngularRate == {
					(16, -1)
				},


	# @sensitivity bmx055xAcceleration = 1024 LSB/g



	#
	#	Accuracy settings list for the sensor. This is a list of (accuracy, cost) pairs.
	#
	#	Noise and offset values are used here for accuracy.
	#
	#	Noise values of Accelerometer can be found in Table 2 of document 1.2 on page 12.
	#
	#	Product of the total supply current and supply voltage in normal mode is used as the cost value.
	#
	#	Supply voltage is 2.4 V which is stated in the footnote on page 11.
	#
	#	Current values (normal mode) of Accelerometer can be found in Table 2 of document 1.2 on page 11.
	#
	accuracy bmx055xAcceleration == {
					(150 n, 312)
				},

	accuracy bmx055yAcceleration == {
					(150 n, 312)
				},

	accuracy bmx055zAcceleration == {
					(150 n, 312)
				},

	#
	#	Offset value of Temperature Sensor can be found in Table 2 of document 1.2 on page 12.
	#
	#	Product of the total supply current and supply voltage in normal mode is used as the cost value.
	#
	#	Current values (normal mode) of Temperature Sensor can be found in Table 2 of document 1.2 on page 11.
	#
	accuracy bmx055Temperature == {
					(4.0 K, 312)
				},

	#
	#	Noise values (normal mode with 4 different presets) of Magnetometer can be found in Table 37 of document 9.2.4 on page 122.
	#
	#	Product of the average current consumption and supply voltage in normal mode is used as the cost value.
	#
	#	Current values (normal mode with 4 different presets) of Magnetometer can be found in Table 37 of document 9.2.4 on page 122.
	#
	accuracy bmx055xMagneto == {
						(1.0 uT, 408),
						(0.6 uT, 1200),
						(0.5 uT, 1920),
						(0.3 uT, 11760)
					},

	accuracy bmx055yMagneto == {
						(1.0 uT, 408),
						(0.6 uT, 1200),
						(0.5 uT, 1920),
						(0.3 uT, 11760)
					},

	accuracy bmx055zMagneto == {
						(1.4 uT, 408),
						(0.6 uT, 1200),
						(0.5 uT, 1920),
						(0.3 uT, 11760)
					},

	#
	#	Noise values of Gyroscope can be found in Table 3 of document 1.2 on page 15.
	#
	#	Product of the total supply current and supply voltage in normal mode is used as the cost value.
	#
	#	Current values (normal mode) of Gyroscope can be found in Table 3 of document 1.2 on page 14.
	#
	accuracy bmx055xAngularRate == {
					(0.1 ajf, 0.012)
				},

	accuracy bmx055xAngularRate == {
					(0.1 ajf, 0.012)
				},

	accuracy bmx055xAngularRate == {
					(0.1 ajf, 0.012)
				}
}